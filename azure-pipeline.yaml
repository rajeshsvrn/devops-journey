# azure-pipelines-gitops.yml
# Updated with authentication fixes and best practices for GitOps

trigger:
  branches:
    include: [develop, qa, main]

variables:
  azureServiceConnection: "azure-federated-identity"
  containerRegistry: "devopsjourney.azurecr.io"
  acrName: "devopsjourney"
  
  # GitOps repository configuration
  gitOpsRepoUrl: "https://github.com/rajeshsvrn/devops-journey.git"
  
  # Build agent pool
  agentPool: "devopsjourneys"
  
  # Environment-specific variables
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/develop') }}:
    targetEnvironment: "development"
    namespace: "develop"
    imageTag: "dev-$(Build.BuildNumber)"
    argocdApp: "devops-app-develop"
    valuesFileSuffix: "values.yaml"
    gitOpsTargetBranch: "develop"
    appUrl: "https://devraj.duckdns.org"

  ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/qa') }}:
    targetEnvironment: "qa"
    namespace: "qa"
    imageTag: "qa-$(Build.BuildNumber)"
    argocdApp: "devops-app-qa"
    valuesFileSuffix: "qa-values.yaml"
    gitOpsTargetBranch: "qa"
    appUrl: "https://qaraj.duckdns.org"

  ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
    targetEnvironment: "production"
    namespace: "production"
    imageTag: "prod-$(Build.BuildNumber)"
    argocdApp: "devops-app-production"
    valuesFileSuffix: "prod-values.yaml"
    gitOpsTargetBranch: "main"
    appUrl: "https://prodraj.duckdns.org"

stages:
  - stage: Build_and_Push_Images
    displayName: "Build & Push Container Images"
    jobs:
      - job: BuildImages
        displayName: "Build Application Images"
        pool:
          name: $(agentPool)
        steps:
          # Checkout with persist credentials for later Git operations
          - checkout: self
            persistCredentials: true
            displayName: "Checkout Source Code"

          # Build and Push Backend Image
          - task: AzureCLI@2
            displayName: "Build and Push Backend Image"
            inputs:
              azureSubscription: "$(azureServiceConnection)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                set -e
                
                echo "ðŸ—ï¸ Building backend image for $(targetEnvironment)"
                echo "ðŸ“¦ Image tag: $(imageTag)"
                
                # Login to ACR
                echo "Logging into ACR: $(acrName)"
                az acr login --name "$(acrName)"
                
                # Build and push backend image
                echo "ðŸ”¨ Building backend image..."
                docker build -t $(containerRegistry)/devops-backend:$(imageTag) \
                  --build-arg BUILD_NUMBER=$(Build.BuildNumber) \
                  --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                  --build-arg VCS_REF=$(Build.SourceVersion) \
                  --label "org.opencontainers.image.source=$(Build.Repository.Uri)" \
                  --label "org.opencontainers.image.revision=$(Build.SourceVersion)" \
                  --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
                  ./backend
                
                docker push $(containerRegistry)/devops-backend:$(imageTag)
                
                # Tag with environment-latest
                docker tag $(containerRegistry)/devops-backend:$(imageTag) \
                  $(containerRegistry)/devops-backend:$(targetEnvironment)-latest
                docker push $(containerRegistry)/devops-backend:$(targetEnvironment)-latest
                
                echo "âœ… Backend image built and pushed successfully!"

          # Build and Push Frontend Image
          - task: AzureCLI@2
            displayName: "Build and Push Frontend Image"
            inputs:
              azureSubscription: "$(azureServiceConnection)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                set -e
                
                echo "ðŸ”¨ Building frontend image..."
                
                # Login to ACR (required for each task)
                az acr login --name "$(acrName)"
                
                # Build and push frontend image
                docker build -t $(containerRegistry)/devops-frontend:$(imageTag) \
                  --build-arg BUILD_NUMBER=$(Build.BuildNumber) \
                  --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                  --build-arg VCS_REF=$(Build.SourceVersion) \
                  --label "org.opencontainers.image.source=$(Build.Repository.Uri)" \
                  --label "org.opencontainers.image.revision=$(Build.SourceVersion)" \
                  --label "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
                  ./frontend
                
                docker push $(containerRegistry)/devops-frontend:$(imageTag)
                
                # Tag with environment-latest
                docker tag $(containerRegistry)/devops-frontend:$(imageTag) \
                  $(containerRegistry)/devops-frontend:$(targetEnvironment)-latest
                docker push $(containerRegistry)/devops-frontend:$(targetEnvironment)-latest
                
                echo "âœ… Frontend image built and pushed successfully!"

          # Optional: Scan images for vulnerabilities
          - task: AzureCLI@2
            displayName: "Scan Images for Vulnerabilities"
            condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
            inputs:
              azureSubscription: "$(azureServiceConnection)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "ðŸ” Scanning images for vulnerabilities..."
                
                # Scan backend image
                az acr task run --registry $(acrName) \
                  --cmd "mcr.microsoft.com/acr/trivy:latest image --exit-code 0 --severity HIGH,CRITICAL $(containerRegistry)/devops-backend:$(imageTag)" \
                  /dev/null || true
                
                # Scan frontend image
                az acr task run --registry $(acrName) \
                  --cmd "mcr.microsoft.com/acr/trivy:latest image --exit-code 0 --severity HIGH,CRITICAL $(containerRegistry)/devops-frontend:$(imageTag)" \
                  /dev/null || true

  - stage: Update_GitOps_Repository
    displayName: "Update GitOps Repository"
    dependsOn: Build_and_Push_Images
    jobs:
      - job: UpdateHelmValues
        displayName: "Update Helm Chart Values"
        pool:
          name: $(agentPool)
        steps:
          # IMPORTANT: Enable access to OAuth token for Git operations
          # This must be enabled in the pipeline settings under "Agent job" > "Additional options"
          # Check "Allow scripts to access the OAuth token"
          
          # Checkout with persist credentials
          - checkout: self
            persistCredentials: true
            clean: true
            fetchDepth: 0  # Full history for proper Git operations
            displayName: "Checkout GitOps Repository"

          # Install required tools
          - script: |
              set -e
              
              echo "ðŸ“¦ Installing required tools..."
              
              # Install yq for YAML manipulation
              YQ_VERSION="v4.35.2"
              wget -qO /tmp/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
              sudo mv /tmp/yq /usr/local/bin/yq
              sudo chmod +x /usr/local/bin/yq
              
              # Verify installation
              yq --version
              
              # Install jq for JSON manipulation (if needed)
              sudo apt-get update && sudo apt-get install -y jq
              
              echo "âœ… Tools installed successfully"
            displayName: "Install Required Tools"

          # Update Helm values using proper Git authentication
          - script: |
              set -e
              
              echo "ðŸ“ Updating Helm values for $(targetEnvironment)"
              echo "ðŸŽ¯ Target ArgoCD app: $(argocdApp)"
              echo "ðŸ·ï¸ Image tag: $(imageTag)"
              
              # Configure Git for the pipeline
              git config user.email "azure-pipelines@devopsjourney.com"
              git config user.name "Azure Pipelines [$(Build.BuildNumber)]"
              
              # Ensure we're on the correct branch
              echo "ðŸ”„ Checking out $(gitOpsTargetBranch) branch..."
              git fetch origin $(gitOpsTargetBranch)
              git checkout $(gitOpsTargetBranch)
              git pull origin $(gitOpsTargetBranch)
              
              # Navigate to Helm chart directory
              HELM_CHART_PATH="devops-gitops/helm-charts/devops-app"
              VALUES_FILE="${HELM_CHART_PATH}/$(valuesFileSuffix)"
              
              # Verify values file exists
              if [ ! -f "$VALUES_FILE" ]; then
                echo "âŒ ERROR: Values file not found: $VALUES_FILE"
                ls -la "${HELM_CHART_PATH}/"
                exit 1
              fi
              
              # Backup current values
              cp "$VALUES_FILE" "${VALUES_FILE}.backup"
              
              # Update image tags using yq
              echo "ðŸ“ Updating image tags in $VALUES_FILE..."
              yq eval ".backend.image.tag = \"$(imageTag)\"" -i "$VALUES_FILE"
              yq eval ".frontend.image.tag = \"$(imageTag)\"" -i "$VALUES_FILE"
              
              # Update metadata if present
              yq eval ".metadata.buildNumber = \"$(Build.BuildNumber)\"" -i "$VALUES_FILE" || true
              yq eval ".metadata.buildDate = \"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\"" -i "$VALUES_FILE" || true
              yq eval ".metadata.gitCommit = \"$(Build.SourceVersion)\"" -i "$VALUES_FILE" || true
              
              # Verify changes
              echo "âœ… Updated values:"
              echo "Backend tag: $(yq eval '.backend.image.tag' "$VALUES_FILE")"
              echo "Frontend tag: $(yq eval '.frontend.image.tag' "$VALUES_FILE")"
              
              # Check if there are actual changes
              if git diff --quiet "$VALUES_FILE"; then
                echo "â„¹ï¸ No changes detected in values file, skipping commit."
                exit 0
              fi
              
              # Show diff for logging
              echo "ðŸ“Š Changes to be committed:"
              git diff "$VALUES_FILE"
              
              # Stage changes
              git add "$VALUES_FILE"
              
              # Create detailed commit message
              COMMIT_MESSAGE="ðŸš€ Deploy $(targetEnvironment): Update images to $(imageTag)

              Environment: $(targetEnvironment)
              Namespace: $(namespace)
              Backend Image: $(containerRegistry)/devops-backend:$(imageTag)
              Frontend Image: $(containerRegistry)/devops-frontend:$(imageTag)
              
              Build Details:
              - Pipeline: $(Build.BuildNumber)
              - Source Branch: $(Build.SourceBranch)
              - Commit: $(Build.SourceVersion)
              - Triggered by: $(Build.RequestedFor)
              - Reason: $(Build.Reason)
              
              ArgoCD Application: $(argocdApp)
              This change will be automatically synced by ArgoCD."
              
              # Commit changes
              git commit -m "$COMMIT_MESSAGE"
              
              echo "âœ… Changes committed successfully"
            displayName: "Update Helm Values"
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

          # Push changes with proper authentication
          - script: |
              set -e
              
              echo "ðŸ“¤ Pushing changes to GitOps repository..."
              
              # Method 1: Using System.AccessToken (Recommended for Azure DevOps repos)
              # This works when "Allow scripts to access the OAuth token" is enabled
              if [ -n "$(System.AccessToken)" ]; then
                echo "Using System.AccessToken for authentication..."
                
                # Configure Git to use the token
                git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)" \
                  push origin HEAD:$(gitOpsTargetBranch)
                
                echo "âœ… Changes pushed successfully using OAuth token!"
              else
                echo "âŒ System.AccessToken not available. Please enable 'Allow scripts to access the OAuth token' in pipeline settings."
                exit 1
              fi
            displayName: "Push Changes to GitOps Repository"
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

          # Alternative push method using Azure DevOps REST API (if direct push fails)
          - task: PowerShell@2
            displayName: "Push via Azure DevOps API (Fallback)"
            condition: failed()
            inputs:
              targetType: 'inline'
              script: |
                $organization = "$(System.TeamFoundationCollectionUri)".Split('/')[3]
                $project = "$(System.TeamProject)"
                $repository = "$(Build.Repository.Name)"
                $branch = "$(gitOpsTargetBranch)"
                
                Write-Host "Attempting push via Azure DevOps REST API..."
                
                # This is a fallback method - implement if needed
                Write-Host "Please ensure 'Allow scripts to access the OAuth token' is enabled in pipeline settings"

  - stage: Verify_Deployment
    displayName: "Verify GitOps Deployment"
    dependsOn: Update_GitOps_Repository
    jobs:
      - job: VerifyDeployment
        displayName: "Verify and Monitor Deployment"
        pool:
          name: $(agentPool)
        steps:
          # Create deployment summary
          - script: |
              set -e
              
              echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
              echo "â•‘           ðŸš€ GitOps Deployment Summary                    â•‘"
              echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
              echo ""
              echo "ðŸ“± ArgoCD Application: $(argocdApp)"
              echo "ðŸŽ¯ Target Environment: $(targetEnvironment)"
              echo "ðŸ·ï¸ Namespace: $(namespace)"
              echo ""
              echo "ðŸ“¦ Container Images:"
              echo "   Backend:  $(containerRegistry)/devops-backend:$(imageTag)"
              echo "   Frontend: $(containerRegistry)/devops-frontend:$(imageTag)"
              echo ""
              echo "ðŸ”— Application URL: $(appUrl)"
              echo ""
              echo "ðŸ“Š Build Information:"
              echo "   Build Number: $(Build.BuildNumber)"
              echo "   Source Branch: $(Build.SourceBranch)"
              echo "   Commit SHA: $(Build.SourceVersion)"
              echo "   Triggered By: $(Build.RequestedFor)"
              echo "   Build Reason: $(Build.Reason)"
              echo ""
              echo "â° ArgoCD Sync Information:"
              echo "   â€¢ ArgoCD will detect changes within its sync interval (typically 3 minutes)"
              echo "   â€¢ You can trigger manual sync via ArgoCD UI or CLI"
              echo "   â€¢ Check ArgoCD application status for deployment progress"
              echo ""
              echo "ðŸ” Monitoring Commands:"
              echo "   argocd app get $(argocdApp)"
              echo "   argocd app sync $(argocdApp)"
              echo "   kubectl get pods -n $(namespace)"
              echo ""
              echo "âœ… GitOps workflow completed successfully!"
              echo "âœ… Git is the source of truth - all changes tracked in version control"
              echo "âœ… Easy rollback: revert the Git commit to rollback deployment"
            displayName: "Deployment Summary"

          # Optional: Wait for ArgoCD sync (requires ArgoCD CLI)
          - script: |
              # This is optional - requires argocd CLI to be installed on agent
              # Uncomment if you want to wait for sync
              
              # echo "â³ Waiting for ArgoCD to sync..."
              # argocd app wait $(argocdApp) --timeout 300 || true
              
              echo "ðŸ“Œ Monitor deployment at: $(appUrl)"
            displayName: "Deployment URLs"

          # Create build artifacts with deployment info
          - task: PublishBuildArtifacts@1
            displayName: "Publish Deployment Info"
            inputs:
              pathToPublish: |
                echo "environment: $(targetEnvironment)" > deployment-info.txt
                echo "namespace: $(namespace)" >> deployment-info.txt
                echo "backend-image: $(containerRegistry)/devops-backend:$(imageTag)" >> deployment-info.txt
                echo "frontend-image: $(containerRegistry)/devops-frontend:$(imageTag)" >> deployment-info.txt
                echo "app-url: $(appUrl)" >> deployment-info.txt
                echo "argocd-app: $(argocdApp)" >> deployment-info.txt
              artifactName: 'deployment-info'