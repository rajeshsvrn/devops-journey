# azure-pipelines-gitops.yml
# Based on your existing GitOps structure and incorporating fixes for Docker/ACR auth, yq for Helm values, and PR creation via REST API to avoid CLI auth issues.

trigger:
  branches:
    include: [develop, qa, main]

variables:
  azureServiceConnection: "azure-federated-identity" # Ensure this service connection is correctly configured in Azure DevOps
  containerRegistry: "devopsjourney.azurecr.io"
  acrName: "devopsjourney" # Added for `az acr login --name`

  # Your GitOps repository (assuming it's the same as your source code repo)
  gitOpsRepoUrl: "https://github.com/rajeshsvrn/devops-journey.git" # Note: If this is a GitHub repo, adjust auth for push (e.g., use PAT instead of persisted credentials)

  # Environment-specific variables - determine image tag, namespace, ArgoCD app, and values file
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/develop') }}:
    targetEnvironment: "development"
    namespace: "develop"
    imageTag: "dev-$(Build.BuildNumber)" # Example: dev-20250725.1
    argocdApp: "devops-app-develop"
    valuesFileSuffix: "values.yaml" # For develop, assumes values.yaml is the base chart values file
    gitOpsTargetBranch: "develop" # Assuming develop branch updates develop manifests

  ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/qa') }}:
    targetEnvironment: "qa"
    namespace: "qa"
    imageTag: "qa-$(Build.BuildNumber)" # Example: qa-20250725.1
    argocdApp: "devops-app-qa"
    valuesFileSuffix: "qa-values.yaml"
    gitOpsTargetBranch: "qa" # Assuming qa branch updates qa manifests

  ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
    targetEnvironment: "production"
    namespace: "production"
    imageTag: "prod-$(Build.BuildNumber)" # Example: prod-20250725.1
    argocdApp: "devops-app-production"
    valuesFileSuffix: "prod-values.yaml"
    gitOpsTargetBranch: "main" # Assuming main branch updates prod manifests

stages:
  - stage: Build_and_Push_Images
    displayName: "Build & Push Container Images"
    jobs:
      - job: BuildImages
        displayName: "Build Application Images"
        pool:
          name: "devopsjourneys" # Ensure this agent pool name is correct and has Docker installed
        steps:
          # Task for Backend Image
          - task: AzureCLI@2
            displayName: "Build and Push Backend Image"
            inputs:
              azureSubscription: "$(azureServiceConnection)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                set -e # Exit immediately if a command exits with a non-zero status.

                echo "üèóÔ∏è Building backend image for $(targetEnvironment)"
                echo "üì¶ Image tag: $(imageTag)"

                # Authenticate Docker with Azure Container Registry (ACR)
                # This uses the Azure CLI context established by the AzureCLI@2 task
                echo "Logging into ACR: $(acrName)"
                az acr login --name "$(acrName)"

                # Build and push backend image
                echo "üî® Building backend image from ./backend directory..."
                # Verify 'backend/' is the correct path to your Dockerfile context
                docker build -t $(containerRegistry)/devops-backend:$(imageTag) ./backend
                docker push $(containerRegistry)/devops-backend:$(imageTag)

                # Also tag with environment-latest for easy reference (useful for quick local pulls)
                docker tag $(containerRegistry)/devops-backend:$(imageTag) $(containerRegistry)/devops-backend:$(targetEnvironment)-latest
                docker push $(containerRegistry)/devops-backend:$(targetEnvironment)-latest

                echo "‚úÖ Backend image built and pushed!"
                echo "Image: $(containerRegistry)/devops-backend:$(imageTag)"

          # Task for Frontend Image
          - task: AzureCLI@2
            displayName: "Build and Push Frontend Image"
            inputs:
              azureSubscription: "$(azureServiceConnection)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                set -e # Exit immediately if a command exits with a non-zero status.

                echo "üî® Building frontend image from ./frontend directory..."
                # Authenticate Docker with Azure Container Registry (ACR)
                # This needs to be repeated in each AzureCLI@2 task if they are separate tasks,
                # as the environment is re-initialized for each task.
                echo "Logging into ACR: $(acrName)"
                az acr login --name "$(acrName)"

                # Verify 'frontend/' is the correct path to your Dockerfile context
                docker build -t $(containerRegistry)/devops-frontend:$(imageTag) ./frontend
                docker push $(containerRegistry)/devops-frontend:$(imageTag)

                # Also tag with environment-latest
                docker tag $(containerRegistry)/devops-frontend:$(imageTag) $(containerRegistry)/devops-frontend:$(targetEnvironment)-latest
                docker push $(containerRegistry)/devops-frontend:$(targetEnvironment)-latest

                echo "‚úÖ Frontend image built and pushed!"
                echo "Image: $(containerRegistry)/devops-frontend:$(imageTag)"

  - stage: Update_Helm_Values
    displayName: "Update Helm Values for GitOps"
    dependsOn: Build_and_Push_Images
    jobs:
      - job: UpdateHelmValues
        displayName: "Update Helm Chart Values"
        pool:
          name: "devopsjourneys"
        steps:
          # Checkout the GitOps repository (which is your current repo)
          # 'self' means checking out the repo that contains this pipeline YAML
          - checkout: self
            displayName: "Checkout Source Code (GitOps Repo)"
            persistCredentials: true  # Persist credentials for subsequent git operations

          # Install yq (best practice for YAML manipulation)
          - script: |
              echo "Installing yq..."
              sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
              sudo chmod +x /usr/local/bin/yq
              yq --version
            displayName: "Install yq"
            condition: and(succeeded(), eq(variables['Agent.OS'], 'Linux'))

          # Map System.AccessToken to an environment variable for script access
          - task: Bash@3
            inputs:
              targetType: 'inline'
              script: 'echo "##vso[task.setvariable variable=SYSTEM_ACCESSTOKEN;issecret=true]$(System.AccessToken)"'
            displayName: 'Expose System.AccessToken'

          - task: AzureCLI@2
            displayName: "Update Helm Values and Create PR via API"
            inputs:
              azureSubscription: "$(azureServiceConnection)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                set -e # Exit immediately if a command exits with a non-zero status.

                echo "üìù Updating Helm values for $(targetEnvironment)"
                echo "üéØ Target ArgoCD app: $(argocdApp)"
                echo "üè∑Ô∏è Image tag: $(imageTag)"

                # Configure git
                git config user.email "azure-devops@devopsjourney.com"
                git config user.name "Azure DevOps Pipeline"

                # Create a new feature branch
                FEATURE_BRANCH="feature/helm-update-$(imageTag)"
                git checkout -b "$FEATURE_BRANCH"

                # Update values file
                HELM_CHART_PATH="devops-gitops/helm-charts/devops-app"
                VALUES_FILE="${HELM_CHART_PATH}/$(valuesFileSuffix)"

                if [ ! -f "$VALUES_FILE" ]; then
                  echo "ERROR: Values file not found: $VALUES_FILE"
                  exit 1
                fi

                echo "üìù Updating values file: $VALUES_FILE using yq"
                yq e ".backend.image.tag = \"$(imageTag)\"" -i "$VALUES_FILE"
                yq e ".frontend.image.tag = \"$(imageTag)\"" -i "$VALUES_FILE"
                echo "‚úÖ Values file updated. Current backend/frontend tags in $VALUES_FILE:"
                yq e '.backend.image.tag' "$VALUES_FILE"
                yq e '.frontend.image.tag' "$VALUES_FILE"

                if git diff --quiet "$VALUES_FILE"; then
                  echo "‚ÑπÔ∏è No changes detected in values file, skipping commit."
                else
                  echo "üì§ Committing changes to feature branch: $FEATURE_BRANCH"
                  git add "$VALUES_FILE"
                  
                  git commit -m "üöÄ Deploy $(targetEnvironment): Update images to $(imageTag)

                  Environment: $(targetEnvironment)
                  Namespace: $(namespace)
                  Backend Image: $(containerRegistry)/devops-backend:$(imageTag)
                  Frontend Image: $(containerRegistry)/devops-frontend:$(imageTag)
                  
                  Pipeline: $(Build.BuildNumber)
                  Branch: $(Build.SourceBranch)
                  Triggered by: $(Build.RequestedFor)
                  
                  ArgoCD App: $(argocdApp) will auto-sync this change"
                  
                  # Push to feature branch (not protected)
                  git push origin "$FEATURE_BRANCH"
                  
                  echo "‚úÖ Changes pushed to $FEATURE_BRANCH!"

                  # Create PR using Azure DevOps REST API
                  echo "üì• Creating pull request from $FEATURE_BRANCH to $(gitOpsTargetBranch) via REST API"
                  API_URL="https://dev.azure.com/devopscult/devopsjourney/_apis/git/repositories/devopsjourney/pullrequests?api-version=7.0"
                  PR_BODY=$(jq -n --arg title "Automated Helm Update for $(targetEnvironment) - Image Tag: $(imageTag)" \
                                 --arg desc "Auto-generated PR for GitOps deployment. Updates image tags to $(imageTag)." \
                                 --arg source "$FEATURE_BRANCH" \
                                 --arg target "$(gitOpsTargetBranch)" \
                                 '{
                                    title: $title,
                                    description: $desc,
                                    sourceRefName: "refs/heads/\($source)",
                                    targetRefName: "refs/heads/\($target)",
                                    isDraft: false
                                  }')

                  RESPONSE=$(curl -s -X POST -H "Authorization: Basic $(echo -n :$SYSTEM_ACCESSTOKEN | base64)" \
                                  -H "Content-Type: application/json" \
                                  -d "$PR_BODY" "$API_URL")

                  if echo "$RESPONSE" | grep -q "pullRequestId"; then
                    echo "‚úÖ PR created successfully!"
                  else
                    echo "‚ùå Failed to create PR: $RESPONSE"
                    exit 1
                  fi

                  echo "‚úÖ PR created! ArgoCD will sync once merged."
                fi

  - stage: Monitor_ArgoCD_Sync_And_Health
    displayName: "Monitor ArgoCD Sync & Health"
    dependsOn: Update_Helm_Values # This ensures we only proceed after the Git commit is pushed
    jobs:
      - job: MonitorSync
        displayName: "Deployment Notification"
        pool:
          name: "devopsjourneys"
        steps:
          - task: AzureCLI@2
            displayName: "Deployment Summary"
            inputs:
              azureSubscription: "$(azureServiceConnection)" # Still needs a service connection for task, even if no az commands are run
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "üîî GitOps Deployment Notification"
                echo "üì± ArgoCD Application: $(argocdApp)"
                echo "üéØ Target Environment: $(targetEnvironment)"
                echo "üì¶ Images deployed:"
                echo "  Backend: $(containerRegistry)/devops-backend:$(imageTag)"
                echo "  Frontend: $(containerRegistry)/devops-frontend:$(imageTag)"

                # Instructions for monitoring. ArgoCD typically syncs every 3 minutes by default.
                echo "‚è∞ ArgoCD will sync automatically within its configured interval (default: 3 minutes)."
                echo "üîç You can monitor the deployment status in the ArgoCD UI or via 'argocd' CLI."

                # Provide links to your ArgoCD applications or public URLs
                if [ "$(targetEnvironment)" = "development" ]; then
                  echo "üåê Development App URL: https://devraj.duckdns.org"
                  echo "ArgoCD UI App URL: YOUR_ARGOCD_UI_URL_FOR_DEV_APP_HERE" # <--- IMPORTANT: Replace with actual link
                elif [ "$(targetEnvironment)" = "qa" ]; then
                  echo "üåê QA App URL: https://qaraj.duckdns.org"
                  echo "ArgoCD UI App URL: YOUR_ARGOCD_UI_URL_FOR_QA_APP_HERE" # <--- IMPORTANT: Replace with actual link
                elif [ "$(targetEnvironment)" = "production" ]; then
                  echo "üåê Production App URL: https://prodraj.duckdns.org"
                  echo "ArgoCD UI App URL: YOUR_ARGOCD_UI_URL_FOR_PROD_APP_HERE" # <--- IMPORTANT: Replace with actual link
                fi

                echo ""
                echo "üéâ GitOps Deployment Workflow Completed Successfully!"
                echo "‚úÖ Pipeline pushes changes to Git, ArgoCD pulls them to deploy."
                echo "‚úÖ No direct Kubernetes API access from pipeline needed for deployment."
                echo "‚úÖ Git is the single source of truth for your application state."
                echo "‚úÖ Full audit trail and easy rollbacks via Git history."
