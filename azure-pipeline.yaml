# azure-pipelines-gitops.yml
# Based on your existing GitOps structure shown in the images.

trigger:
  branches:
    include: [develop, qa, main]

variables:
  azureServiceConnection: "azure-federated-identity"
  containerRegistry: "devopsjourney.azurecr.io"

  # Your GitOps repository (assuming it's the same as your source code repo)
  gitOpsRepoUrl: "https://github.com/rajeshsvrn/devops-journey.git"
  gitOpsRepoBranch:
    "main" # GitOps changes should typically go to the main branch if ArgoCD is watching main.
    # If ArgoCD watches 'develop' for the 'development' app, use 'develop' here for that stage.
    # For simplicity, if all environments sync from 'main' (e.g., Kustomize overlays in main),
    # then push to main. If you have different branches for each env, adjust accordingly.
    # Let's assume you push environment-specific changes back to the *source* branch for now.

  # Environment-specific variables
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/develop') }}:
    targetEnvironment: "development"
    namespace: "develop"
    imageTag: "dev-$(Build.BuildNumber)" # Format: dev-YYYYMMDD.X
    argocdApp: "devops-app-develop"
    valuesFileSuffix: "values.yaml" # For develop, assumes values.yaml is the base

  ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/qa') }}:
    targetEnvironment: "qa"
    namespace: "qa"
    imageTag: "qa-$(Build.BuildNumber)" # Format: qa-YYYYMMDD.X
    argocdApp: "devops-app-qa"
    valuesFileSuffix: "qa-values.yaml"

  ${{ elseif eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
    targetEnvironment: "production"
    namespace: "production"
    imageTag: "prod-$(Build.BuildNumber)" # Format: prod-YYYYMMDD.X
    argocdApp: "devops-app-production"
    valuesFileSuffix: "prod-values.yaml"

stages:
  - stage: Build_and_Push_Images
    displayName: "Build & Push Container Images"
    jobs:
      - job: BuildImages
        displayName: "Build Application Images"
        pool:
          name: "devopsjourneys" # Ensure this agent pool name is correct and has Docker installed
        steps:
          # Task for Backend Image
          - task: AzureCLI@2
            displayName: "Build and Push Backend Image"
            inputs:
              azureSubscription: "$(azureServiceConnection)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "üèóÔ∏è Building backend image for $(targetEnvironment)"
                echo "üì¶ Image tag: $(imageTag)"

                # AzureCLI@2 handles ACR login automatically via the service connection
                # No need for: az acr login --name devopsjourney

                # Build and push backend image
                echo "üî® Building backend image from ./backend directory..."
                docker build -t $(containerRegistry)/devops-backend:$(imageTag) ./backend
                docker push $(containerRegistry)/devops-backend:$(imageTag)

                # Also tag as environment-latest for easy reference (useful for quick local pulls)
                docker tag $(containerRegistry)/devops-backend:$(imageTag) $(containerRegistry)/devops-backend:$(targetEnvironment)-latest
                docker push $(containerRegistry)/devops-backend:$(targetEnvironment)-latest

                echo "‚úÖ Backend image built and pushed!"
                echo "Image: $(containerRegistry)/devops-backend:$(imageTag)"

          # Task for Frontend Image
          - task: AzureCLI@2
            displayName: "Build and Push Frontend Image"
            inputs:
              azureSubscription: "$(azureServiceConnection)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "üî® Building frontend image from ./frontend directory..."
                docker build -t $(containerRegistry)/devops-frontend:$(imageTag) ./frontend
                docker push $(containerRegistry)/devops-frontend:$(imageTag)

                # Also tag as environment-latest
                docker tag $(containerRegistry)/devops-frontend:$(imageTag) $(containerRegistry)/devops-frontend:$(targetEnvironment)-latest
                docker push $(containerRegistry)/devops-frontend:$(targetEnvironment)-latest

                echo "‚úÖ Frontend image built and pushed!"
                echo "Image: $(containerRegistry)/devops-frontend:$(imageTag)"

  - stage: Update_Helm_Values
    displayName: "Update Helm Values for GitOps"
    dependsOn: Build_and_Push_Images # This ensures images are built before attempting to update manifest
    jobs:
      - job: UpdateHelmValues
        displayName: "Update Helm Chart Values"
        pool:
          name: "devopsjourneys"
        steps:
          # Checkout the GitOps repository (which is your current repo)
          - checkout: self # This checks out the current repo, ensuring latest source code and manifests are available.
            displayName: "Checkout Source Code (GitOps Repo)"

          # Install yq (best practice for YAML manipulation)
          - script: |
              echo "Installing yq..."
              # You might need to adjust this based on your agent's OS (e.g., apt install for Debian/Ubuntu)
              # This is a common way to get it on a fresh Linux VM
              sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
              sudo chmod +x /usr/local/bin/yq
              yq --version
            displayName: "Install yq"
            condition: and(succeeded(), eq(variables['Agent.OS'], 'Linux')) # Only install on Linux agents
            # Add a condition for Windows if needed, or if yq is already on agent, remove this step.

          - task: AzureCLI@2
            displayName: "Update Helm Values in GitOps Repo"
            inputs:
              azureSubscription: "$(azureServiceConnection)" # Used for potential az commands if any, but git is primary here
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                set -e # Ensure script exits on first failure

                echo "üìù Updating Helm values for $(targetEnvironment)"
                echo "üéØ Target ArgoCD app: $(argocdApp)"
                echo "üè∑Ô∏è Image tag: $(imageTag)"

                # Configure git with a non-interactive user
                git config --global user.email "azure-devops@devopsjourney.com"
                git config --global user.name "Azure DevOps Pipeline"

                # Navigate to the correct chart directory relative to your repo root
                # Assuming your helm chart is at ./devops-gitops/helm-charts/devops-app/
                HELM_CHART_PATH="./devops-gitops/helm-charts/devops-app"
                VALUES_FILE="${HELM_CHART_PATH}/$(valuesFileSuffix)"

                if [ ! -f "$VALUES_FILE" ]; then
                  echo "ERROR: Values file not found: $VALUES_FILE"
                  exit 1
                fi

                echo "üìù Updating values file: $VALUES_FILE using yq"

                # Update backend image tag
                yq e ".backend.image.tag = \"$(imageTag)\"" -i "$VALUES_FILE"
                # Update frontend image tag
                yq e ".frontend.image.tag = \"$(imageTag)\"" -i "$VALUES_FILE"

                echo "‚úÖ Values file updated. Current backend/frontend tags in $VALUES_FILE:"
                yq e '.backend.image.tag' "$VALUES_FILE"
                yq e '.frontend.image.tag' "$VALUES_FILE"

                # Check if there are actually changes to commit
                # Use 'git diff' relative to the checkout directory
                if git diff --quiet $VALUES_FILE; then
                  echo "‚ÑπÔ∏è No changes detected in values file, skipping commit."
                else
                  echo "üì§ Committing changes to $(Build.SourceBranch)..."
                  git add "$VALUES_FILE"

                  git commit -m "üöÄ Deploy $(targetEnvironment): Update images to $(imageTag)

                  Environment: $(targetEnvironment)
                  Namespace: $(namespace)
                  Backend Image: $(containerRegistry)/devops-backend:$(imageTag)
                  Frontend Image: $(containerRegistry)/devops-frontend:$(imageTag)

                  Pipeline: $(Build.BuildNumber)
                  Branch: $(Build.SourceBranch)
                  Triggered by: $(Build.RequestedFor)

                  ArgoCD App: $(argocdApp) will auto-sync this change"

                  # Push changes back to the original branch (e.g., 'develop' or 'main')
                  # Azure DevOps pipeline typically clones in detached HEAD state,
                  # so 'git push origin HEAD' might push to the default branch for the repo.
                  # It's safer to explicitly push to the source branch.
                  git push origin HEAD:"$(Build.SourceBranchName)"
                  echo "‚úÖ Changes pushed to repository!"
                  echo "üöÄ ArgoCD will detect changes and deploy automatically"
                fi

  - stage: Monitor_ArgoCD_Sync_And_Health
    displayName: "Monitor ArgoCD Sync & Health"
    dependsOn: Update_Helm_Values
    jobs:
      - job: MonitorSync
        displayName: "Monitor ArgoCD Deployment"
        pool:
          name: "devopsjourneys"
        steps:
          - task: AzureCLI@2
            displayName: "Deployment Notification"
            inputs:
              azureSubscription: "$(azureServiceConnection)"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "üîî ArgoCD Sync Notification"
                echo "üì± App: $(argocdApp)"
                echo "üéØ Environment: $(targetEnvironment)"
                echo "üì¶ Images deployed:"
                echo "  Backend: $(containerRegistry)/devops-backend:$(imageTag)"
                echo "  Frontend: $(containerRegistry)/devops-frontend:$(imageTag)"

                # Optional: Instructions for manual ArgoCD sync or monitoring
                echo "‚è∞ ArgoCD will sync within its configured interval (default 3 minutes)."
                echo "üîç You can monitor the deployment status in the ArgoCD UI or via 'argocd' CLI:"

                if [ "$(targetEnvironment)" = "development" ]; then
                  echo "üåê Development: https://devraj.duckdns.org"
                  echo "ArgoCD UI: YOUR_ARGOCD_UI_URL_FOR_DEVELOPMENT_APP" # Replace with actual URL
                elif [ "$(targetEnvironment)" = "qa" ]; then
                  echo "üåê QA: https://qaraj.duckdns.org"
                  echo "ArgoCD UI: YOUR_ARGOCD_UI_URL_FOR_QA_APP" # Replace with actual URL
                elif [ "$(targetEnvironment)" = "production" ]; then
                  echo "üåê Production: https://prodraj.duckdns.org"
                  echo "ArgoCD UI: YOUR_ARGOCD_UI_URL_FOR_PRODUCTION_APP" # Replace with actual URL
                fi

                echo ""
                echo "üéâ GitOps Deployment Initiated Successfully!"
                echo "‚úÖ No direct Kubernetes API access from pipeline required for deployment."
                echo "‚úÖ ArgoCD handles all cluster operations."
                echo "‚úÖ Git is the single source of truth."
                echo "‚úÖ Full audit trail in Git history."
                echo ""
                echo "üìã Deployment Summary:"
                echo "  Environment: $(targetEnvironment)"
                echo "  Namespace: $(namespace)"
                echo "  ArgoCD App: $(argocdApp)"
                echo "  Image Tag: $(imageTag)"
                echo "  Pipeline: $(Build.BuildNumber)"
